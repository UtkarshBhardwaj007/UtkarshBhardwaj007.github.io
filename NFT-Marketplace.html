<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFT Marketplace - Utkarsh Bhardwaj</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" href="assets/css/styles.css">
</head>
<body>
    <div class="container">
        <div class="content">
            <a href="index.html" class="back-link">
                <span class="icon">←</span> Back to Home
            </a>

            <h1>NFT Marketplace</h1>

            <h2>1. Goal</h2>
            <ul>
                <li>The goal is to create a custom Polkadot SDK Pallet that acts as an NFT Marketplace. Our NFTs will represent kitties, which will be a digital pets that can be created, traded, and more.</li>
                <li>This Pallet could then be included into a Polkadot SDK blockchain and used to launch a Web3 application on the Polkadot Network.</li>
            </ul>

            <h2>2. Runtime</h2>
            <ul>
                <li>At the heart of a blockchain is a state transition function (STF). This is the logic of the blockchain, and defines all the ways a blockchain is allowed to manipulate the blockchain state.</li>
                <li>In the polkadot-sdk we refer to this logic as the blockchain's <code>runtime</code>.</li>
            </ul>

            <h2>3. NFTs</h2>
            <p>Non-Fungible Tokens (NFTs) are a type of token which can be created and traded on a blockchain. As their name indicated, each NFT is totally unique, and therefore non-fungible with one another. NFTs can be used for many things, for example: Representing real world assets, Ownership Rights, Access Rights, Digital assets, Music, Images etc.</p>

            <h2>4. Macros in FRAME</h2>
            <ul>
                <li><strong>FRAME</strong> uses Macros to simplify the development of Pallets, while keeping all of the benefits of using Rust. You can identify most macros in one of two forms:
                    <ul>
                        <li><code>#[macro_name]</code>: <strong>Attribute macros</strong>, which are applied on top of valid rust syntax.</li>
                        <li><code>macro_name!(...)</code>: <strong>Declarative macros</strong>, which can define their own internal syntax.</li>
                    </ul>
                </li>
            </ul>

            <p>The entrypoint for all the <code>FRAME</code> macros looks like this:</p>
            <pre><code class="language-rust">#[frame::pallet(dev_mode)]
pub mod pallet {
    // -- snip --
}</code></pre>

            <p>We wrap all of our Pallet code inside of this entrypoint, which allows our macros to have context of all the details inside. Without this, there would be no way for the macros defined inside the entry point to to communicate information to one another.</p>
            <p>The unfortunate limitation here is that wherever we want to use <code>FRAME</code> macros, we must basically do it in a single file and all enclosed by the <code>#[frame::pallet]</code> macro entrypoint.</p>

            <h2>5. Basic Pallet Structure</h2>
            <pre><code class="language-rust">use frame::prelude::*;
pub use pallet::*;

#[frame::pallet]
pub mod pallet {
    use super::*;

    #[pallet::pallet]
    pub struct Pallet&lt;T&gt;(core::marker::PhantomData&lt;T&gt;);

    #[pallet::config]  // snip
    #[pallet::event]   // snip
    #[pallet::error]   // snip
    #[pallet::storage] // snip
    #[pallet::call]    // snip
}</code></pre>

            <h3>5.1 Pallet Struct (<code>#[pallet::pallet]</code>)</h3>
            <ul>
                <li>The Pallet struct is the anchor on which we implement all logic and traits for our Pallet.</li>
            </ul>

            <pre><code class="language-rust">#[pallet::pallet]
pub struct Pallet&lt;T&gt;(core::marker::PhantomData&lt;T&gt;);

// Function implementations
impl&lt;T: Config&gt; Pallet&lt;T&gt; {
    // -- snip --
}

// Trait implementations
impl&lt;T: Config&gt; Hooks for Pallet&lt;T&gt; {
    fn on_finalize() {
        // -- snip --
    }
}

// And we can access these functions inside trait implementations as follows:
pallet_kitties::Pallet::<T>::on_finalize();</code></pre>

            <ul>
                <li>In fact, many traits are automatically implemented on top of <code>Pallet</code> and are accessible thanks to the <code>#[pallet::pallet]</code> attribute macro. You can see all the different traits implemented on Pallet by looking at the <strong>autogenerated Rust docs</strong>.</li>
            </ul>

            <h3>5.2 Callable Functions (<code>#[pallet::call]</code>)</h3>
            <p>There are two types of functions exposed by Pallets:</p>
            <ul>
                <li>Internal Functions: Regular functions only callable from within the blockchain.</li>
                <li>Callable Functions: The way users interact with the blockchain is through transactions. Those transactions are processed, and then dispatched to callable functions within the blockchain.</li>
            </ul>

            <h4>5.2.1 Pallet Call Macro</h4>
            <ul>
                <li><code>FRAME</code> allows you to create callable functions by introducing the <code>#[pallet::call]</code> macro on top of a normal function implementation code block.</li>
            </ul>

            <pre><code class="language-rust">#[pallet::call]
impl&lt;T: Config&gt; Pallet&lt;T&gt; {
    // All of the functions in this `impl` will be callable by users.
}</code></pre>

            <ul>
                <li>The macro enforces rules on how these functions should be defined. They are discussed in the following sections.</li>
                <li><strong>NOTE</strong>: "Users submit an extrinsic to the blockchain, which is dispatched to a Pallet call."</li>
                <li><strong>NOTE</strong>: An <code>extrinsic</code> is any message from the outside coming to the blockchain. A <code>transaction</code> is specifically a signed message coming from the outside.</li>
            </ul>

            <h4>5.2.2 Origin</h4>
            <ul>
                <li>The first parameter of every callable function must be <code>origin: OriginFor&lt;T&gt;</code>.</li>
                <li>It describes where the call is calling from, and allows us to perform simple access control logic based on that information.</li>
                <li>The most common origin is the signed origin, which is a regular transaction.</li>
                <li>Origin is a superset of the idea of <code>msg.sender</code> (from Smart contract development). No longer do we need to assume that every call to a callable function is coming from an external account. We could have pallets call one another, or other internal logic trigger a callable function.</li>
            </ul>

            <h4>5.2.3 Dispatch Result</h4>
            <ul>
                <li>Every callable function must return a DispatchResult, which is simply defined as:</li>
            </ul>

            <pre><code class="language-rust">pub type DispatchResult = Result&lt;(), sp_runtime::DispatchError&gt;;</code></pre>

            <ul>
                <li>So these functions can return <code>Ok(())</code> or some <code>Err(DispatchError)</code>. You can easily define new <code>DispatchError</code> variants using the included <code>#[pallet::error]</code>.</li>
            </ul>

            <h3>5.3 Pallet Config (<code>#[pallet::config]</code>)</h3>
            <ul>
                <li>Each pallet includes a <strong>trait</strong> <code>Config</code> which is used to configure the pallet in the context of your larger runtime.</li>
            </ul>

            <pre><code class="language-rust">#[pallet::config]
pub trait Config: frame_system::Config {
    // -- snip --
}</code></pre>

            <ul>
                <li>Wherever you see <code>T</code> (from <code>&lt;T: Config&gt;</code>), you have access to our <code>trait Config</code> and the types and functions inside of it.</li>
            </ul>

            <h3>5.4 Pallet Events (<code>#[pallet::event]</code>)</h3>
            <ul>
                <li>Events allow Pallets to express that something has happened, and allows off-chain systems like indexers or block explorers to track certain state transitions.</li>
                <li>The <code>#[pallet::event]</code> macro acts on an enum Event.</li>
            </ul>

            <pre><code class="language-rust">#[pallet::event]
#[pallet::generate_deposit(pub(super) fn deposit_event)]
pub enum Event&lt;T: Config&gt; {
    Created { owner: T::AccountId },
}</code></pre>

            <ul>
                <li>The macro <code>#[pallet::generate_deposit(pub(super) fn deposit_event)]</code> generates a helper function that handles event conversion and system integration.</li>
            </ul>

            <pre><code>Pallet Event                              // Your event
    ↓ (From conversion)
Pallet's Runtime Event                    // Runtime-level event
    ↓ (Into conversion)
frame_system::Config::RuntimeEvent        // System-level event
    ↓
Stored in block's event log</code></pre>

            <h3>5.5 Storage (<code>#[pallet::storage]</code>)</h3>

            <h4>5.5.1 Storage Values</h4>
            <ul>
                <li>The most basic storage type for a blockchain is a single <code>StorageValue</code>. A <code>StorageValue</code> is used to place a single object into the blockchain storage. A single object can be as simple as a single type like a <code>u32</code>, or more complex structures, or even vectors.</li>
                <li><code>StorageValue</code> places a single entry into the merkle trie. So when you read data, you read all of it. When you write data, you write all of it. This is in contrast to a <code>StorageMap</code>.</li>
                <li>Here is how it is created in <code>FRAME</code>:</li>
            </ul>

            <pre><code class="language-rust">#[pallet::storage]
pub(super) type CountForKitties&lt;T: Config&gt; = StorageValue&lt;Value = u32&gt;;</code></pre>

            <ul>
                <li>Our storage (<code>CountForKitties</code>) is a type alias for a new instance of <code>StorageValue</code>.</li>
                <li><code>StorageValue</code> has a parameter <code>Value</code> where we can define the type we want to place in storage. In this case, it is a simple <code>u32</code>.</li>
                <li>Also notice <code>CountForKitties</code> is generic over <code>&lt;T: Config&gt;</code>. <strong>All of our storage must be generic</strong> over <code>&lt;T: Config&gt;</code> even if we are not using it directly. <strong>Macros</strong> use this generic parameter to fill in behind the scene details to make the <code>StorageValue</code> work.</li>
                <li>Visibility of the type is up to you and your needs, but you need to remember that blockchains are public databases. So <code>pub</code> in this case is only about Rust, and allowing other modules to access this storage and its APIs directly. You cannot make storage on a blockchain "private", and even if you make this storage without <code>pub</code>, there are low level ways to manipulate the storage in the database.</li>
                <li><code>StorageValue</code> has a <code>QueryKind</code> parameter which defaults to <code>OptionQuery</code>. We can change this to <code>ValueQuery</code> to return the default values in case the value is not found to get rid of the <code>unwrap_or()</code> in the <code>get()</code> calls. If your type does not implement <code>Default</code>, you can't use <code>ValueQuery</code>.</li>
                <li><code>OnEmpty</code> type defines the behavior of the <code>QueryKind</code> type. When you call get, and the storage is empty, the <code>OnEmpty</code> configuration kicks in. You <strong>CAN</strong> modify <code>OnEmpty</code> to return a custom value, rather than Default.</li>
            </ul>

            <h4>5.5.2 Storage Maps</h4>
            <ul>
                <li>A <code>StorageMap</code> is a key-value store. Declaring a new StorageMap is very similar to a StorageValue:</li>
            </ul>

            <pre><code class="language-rust">#[pallet::storage]
pub(super) type Kitties&lt;T: Config&gt; = StorageMap&lt;Key = [u8; 32], Value = ()&gt;;</code></pre>

            <ul>
                <li>A <code>StorageValue</code> stores a single value into a single key in the Merkle Trie. A <code>StorageMap</code> stores multiple values under different storage keys, all into different places in the Merkle Trie.</li>
                <li><code>StorageValue</code> puts all of the data into a single object and stores that all into a single key in the Merkle Trie. In <code>StorageMap</code>, each value is stored in its own spot in the Merkle Trie, so you are able to read just one key / value on its own. This can be way more efficient for reading just a single item. However, trying to read multiple items from a <code>StorageMap</code> is extremely expensive.</li>
                <li><strong>Ensure</strong>: <code>ensure!</code> is a macro which expands to the following:</li>
            </ul>

            <pre><code class="language-rust">ensure!(!Kitties::<T>::contains_key(my_key), Error::<T>::DuplicateKitty);
//              |   |
//              |   |  This gets expanded to the following:
//              V   V
if (Kitties::<T>::contains_key(my_key)) {
    return Err(Error::<T>::DuplicateKitty.into());
}</code></pre>

            <ul>
                <li><strong>NOTE</strong>: In both <code>StorageValue</code> and <code>StorageMap</code>, the <code>insert</code> API cannot fail. If you try to insert a value into a key that already exists, it will overwrite the existing value.</li>
                <li><strong>NOTE</strong>: To check if a value exists, you can use the <code>exists</code> API for <code>StorageValue</code> and <code>contains_key</code> for <code>StorageMap</code>.</li>
            </ul>

            <h4>5.5.3 Traits Required for Storage</h4>
            <ul>
                <li>When storing a custom struct in runtime storage like the <code>Kitty</code> struct, you need to implement the following traits on the struct:
                    <ul>
                        <li><code>Encode</code>: The object must be encodable to bytes using <code>parity_scale_codec</code>.</li>
                        <li><code>Decode</code>: The object must be decodable from bytes using <code>parity_scale_codec</code>.</li>
                        <li><code>MaxEncodedLen</code>: When the object is encoded, it must have an upper limit to its size.</li>
                        <li><code>TypeInfo</code>: The object must be able to generate metadata describing the object.</li>
                    </ul>
                </li>
                <li>We can use the <code>#[derive(...)]</code> macros to generate the implementation of these traits.</li>
            </ul>

            <h4>5.5.4 Parity Scale Codec (<code>parity_scale_codec</code>)</h4>
            <p><code>SCALE</code> defines how every object in the <code>polkadot-sdk</code> is represented in bytes. SCALE is:</p>
            <ul>
                <li>Simple to define.</li>
                <li>Not Rust-specific (but happens to work great in Rust).
                    <ul>
                        <li>Easy to derive codec logic: <code>#[derive(Encode, Decode)]</code></li>
                        <li>Viable and useful for APIs like: <code>MaxEncodedLen</code> and <code>TypeInfo</code></li>
                        <li>It does not use <code>Rust std</code>, and thus can compile to <code>Wasm no_std</code>.</li>
                    </ul>
                </li>
                <li>Consensus critical / bijective; one value will always encode to one blob and that blob will only decode to that value.</li>
                <li>Supports a copy-free decode for basic types on LE architectures (like Wasm).</li>
                <li>It is about as thin and lightweight as can be.</li>
            </ul>

            <h4>5.5.5 Max Encoded Length (<code>MaxEncodedLen</code>)</h4>
            <ul>
                <li>We track the maximum encoded length of an object: <code>MaxEncodedLen</code> and use that information to predict in the worst case scenario how much data will be used when we store it.</li>
                <li>For a <code>u8</code>, the <code>max_encoded_len()</code> is always: <code>1 byte</code>. For a <code>u64</code>, it is always: <code>8 bytes</code>. For a basic <code>enum</code>, it is also just <code>1 byte</code>, since an enum can represent up to 256 variants.</li>
                <li>For a <code>struct</code>, the <code>max_encoded_len()</code> will be the <strong>sum</strong> of the <code>max_encoded_len()</code> of all items in the struct.</li>
            </ul>

            <h4>5.5.6 Type Info (<code>TypeInfo</code>)</h4>
            <ul>
                <li><code>TypeInfo</code> is a trait that is used to generate metadata about a type.</li>
                <li>This trait is key for off-chain interactions with your blockchain. It is used to generate metadata for all the objects and types in your blockchain. Metadata exposes all the details of your blockchain to the outside world, allowing us to dynamically construct APIs to interact with the blockchain.</li>
                <li><strong>Skip Type Params</strong>: <code>TypeInfo</code> derive macro isn't very "smart". <code>TypeInfo</code> generates relevant metadata about the types used in your blockchain. However, part of our <code>Kitty</code> type is the generic parameter <code>T</code>, and it really does not make any sense to generate <code>TypeInfo</code> for <code>T</code>. To make <code>TypeInfo</code> work while we have <code>T</code>, we need to include the additional line:</li>
            </ul>

            <pre><code class="language-rust">#[scale_info(skip_type_params(T))]</code></pre>

            <h3>5.6 Pallet Errors (<code>#[pallet::error]</code>)</h3>
            <ul>
                <li><strong>NOTE</strong>: You cannot panic inside the runtime.</li>
                <li>All of our callable functions use the <code>DispatchResult</code> type. The <code>DispatchResult</code> type expects either <code>Ok(())</code> or <code>Err(DispatchError)</code>.</li>
            </ul>

            <pre><code class="language-rust">// The `DispatchError` type has a few variants that you can easily construct / use.
// For example, if you want to be a little lazy, you can simply return a `&'static str`:
fn always_error() -> DispatchResult {
    return Err("this function always errors".into())
}

// But the better option is to return a custom Pallet Error:
fn custom_error() -> DispatchResult {
    return Err(Error::<T>::CustomPalletError.into())
}

// Notice in both of these cases we had to call into() to convert our input type 
// into the DispatchError type.</code></pre>

            <ul>
                <li>To create <code>CustomPalletError</code>, simply add a new variants to the <code>enum Error&lt;T&gt;</code> type.</li>
            </ul>

            <pre><code class="language-rust">#[pallet::error]
pub enum Error&lt;T&gt; {
    /// This is a description for the error.
    ///
    /// This description can be shown to the user in UIs, so make it descriptive.
    CustomPalletError,
}</code></pre>

            <h2>6. Generating Unique DNAs for Kitties</h2>

            <h3>6.1 Randomness</h3>
            <p>Generating randomness on a blockchain is extremely difficult because any kind of randomness function must generate exactly the same randomness for all nodes. <strong>NOTE</strong> that Polkadot does provide access to a verifiable random function (VRF).</p>

            <h3>6.2 Uniqueness</h3>
            <p>There are different levels of uniqueness we can achieve using data from our blockchain.</p>
            <ul>
                <li><code>frame_system::Pallet::<T>::parent_hash()</code>: The hash of the previous block. This will ensure uniqueness for every fork of the blockchain.</li>
                <li><code>frame_system::Pallet::<T>::block_number()</code>: The number of the current block. This will obviously be unique for each block.</li>
                <li><code>frame_system::Pallet::<T>::extrinsic_index()</code>: The number of the extrinsic in the block that is being executed. This will be unique for each extrinsic in a block.</li>
                <li><code>CountForKitties::<T>::get()</code>: The number of kitties in our blockchain.</li>
            </ul>

            <h3>6.3 Hash</h3>
            <ul>
                <li><code>FRAME</code> provides access to the hash function: <code>frame::primitives::BlakeTwo256</code></li>
            </ul>

            <pre><code class="language-rust">// Collect our unique inputs into a single object.
let unique_payload = (item1, item2, item3);
// To use the `hash_of` API, we need to bring the `Hash` trait into scope.
use frame::traits::Hash;
// Hash that object to get a unique identifier.
let hash: [u8; 32] = BlakeTwo256::hash_of(&unique_payload).into();</code></pre>

            <ul>
                <li>The <code>hash_of</code> API comes from the <code>Hash</code> trait and takes any <code>encode</code>-able object, and returns a <code>H256</code>, which is a 256-bit hash. As you can see in the code above, it is easy to convert that to a <code>[u8; 32]</code> by just calling <code>.into()</code>, since these two types are equivalent.</li>
            </ul>


            <h2>7. Redundant Storage (Track Owned Kitties)</h2>
            <p>As a rule, you only want to store data in your blockchain which is necessary for consensus. We should evaluate what queries we will need to perform on the stored data and then decide that we may indeed need to have redundant storage in order to make the queries efficient.</p>

            <h3>7.1 Iteration</h3>
            <p>In general iteration should be avoided where possible, but if unavoidable it is critical that iteration be bounded in size. We literally cannot allow code on our blockchain which would do unbounded iteration, else that would stall our blockchain, which needs to produce a new block on a regular time interval.</p>

            <ul>
                <li><strong>Iteration in Maps</strong>: When you iterate over a map, you need to make 2 considerations: That the map may not have a bounded upper limit and That each access to the map is very expensive to the blockchain (each is a unique read to the merkle trie). If you want to do iteration, probably you do <strong>NOT</strong> want to use a map.</li>
                <li><strong>Iteration in Vectors</strong>: When you iterate over a vector, the only real consideration you need to have is how large that vector is. Accessing large files from the database is going to be slower than accessing small files. Once you access the vector, iterating over it and manipulating it is relatively <strong>cheap</strong> compared to any kind of storage map (<strong>but not zero</strong>, complexity about vector access still applies). If you want to do iteration, you definitely would prefer to use a vector.</li>
            </ul>

            <h3>7.2 Storage Optimisations</h3>
            <p>For vectors, it is not necessary to read data from the storage, append to it and write it back to storage. Instead we can use <code>FRAME's</code> Storage Abstractions and simply append to the vector like below:</p>

            <pre><code class="language-rust">// Naive way
// Get/read the vector from storage
let mut owned_kitties: Vec&lt;[u8; 32]&gt; = KittiesOwned::<T>::get(owner);
// Append to the vector
owned_kitties.append(new_kitty);
// Write the vector back to storage
KittiesOwned::<T>::insert(owner, owned_kitties);

// Better way
KittiesOwned::<T>::append(owner, new_kitty);</code></pre>

            <h3>7.3 Bounded Vectors</h3>
            <ul>
                <li>The <code>BoundedVec</code> type is a zero-overhead abstraction over the <code>Vec</code> type allowing us to control the maximum number of item in the vector. To create a new BoundedVec with a maximum of 100 u8s, you can do the following:</li>
            </ul>

            <pre><code class="language-rust">let my_bounded_vec = BoundedVec::<u8, ConstU32<100>>::new();</code></pre>

            <ul>
                <li>The syntax here is very similar to creating a <code>Vec</code>, however we include a second generic parameter which tells us the bound. The easiest way to set this bound is using the <code>ConstU32&lt;T&gt;</code> type.</li>
                <li>The <code>BoundedVec</code> type has almost all the same APIs as a <code>Vec</code>. The main difference is the fact that a <code>BoundedVec</code> cannot always accept a new item. So rather than having <code>push</code>, <code>append</code>, <code>extend</code>, <code>insert</code>, and so on, you have <code>try_push</code>, <code>try_append</code>, <code>try_extend</code>, <code>try_insert</code>, etc. So converting the logic of a <code>Vec</code> to a <code>BoundedVec</code> can be as easy as:</li>
            </ul>

            <pre><code class="language-rust">// Append to a normal vec.
vec.append(item);
// Try append to a bounded vec, handling the error.
bounded_vec.try_append(item).map_err(|_| Error::<T>::TooManyOwned)?;</code></pre>

            <ul>
                <li>Just like for <code>Vec</code>, our <code>BoundedVec</code> also has an optimized <code>try_append</code> API for trying to append a new item to the <code>BoundedVec</code> without having to read the whole vector in the runtime:</li>
            </ul>

            <pre><code class="language-rust">// Append to a normal vec.
KittiesOwned::<T>::append(item);
// Try append to a bounded vec, handling the error.
KittiesOwned::<T>::try_append(item).map_err(|_| Error::<T>::TooManyOwned)?;</code></pre>
<h2>8. Pallet Coupling</h2>
            <h3>8.1 What is Pallet Coupling?</h3>
            <p>Pallet coupling refers to how one Substrate pallet interacts with another. There are two patterns:</p>
            <ul>
                <li><strong>Tight Coupling</strong>: Direct dependency on a specific pallet.</li>
                <li><strong>Loose Coupling</strong>: Dependency on a trait interface, not a specific pallet.</li>
            </ul>

            <h3>8.2 Tight Coupling</h3>
            <h4>8.2.1 How It Works</h4>
            <ul>
                <li><strong>Supertrait Inheritance</strong>: Your pallet's <code>Config</code> trait inherits from another pallet's <code>Config</code> trait Example:</li>
            </ul>

            <pre><code class="language-rust">#[pallet::config]
pub trait Config: frame_system::Config + pallet_balances::Config { ... }</code></pre>

            <ul>
                <li>Here, your pallet is tightly coupled to both <code>frame_system</code> and <code>pallet_balances.</code></li>
            </ul>

            <h4>8.2.2 Key Characteristics</h4>
            <ul>
                <li>Direct Access: You can use the other pallet's:
                    <ul>
                        <li><strong>Types</strong>: T::AccountId (from frame_system).</li>
                        <li><strong>Functions</strong>: frame_system::Pallet::<T>::block_number().</li>
                        <li><strong>Storage</strong>: Directly read/write to the other pallet's storage.</li>
                    </ul>
                </li>
                <li>Example using pallet_balances:</li>
            </ul>

            <pre><code class="language-rust">let total_issuance = pallet_balances::Pallet::<T>::total_issuance();</code></pre>

            <h4>8.2.3 Pros & Cons</h4>
            <ul>
                <li>✅ Pros:
                    <ul>
                        <li>Simple to implement.</li>
                        <li>Full access to the other pallet's APIs.</li>
                    </ul>
                </li>
                <li>❌ Cons:
                    <ul>
                        <li>Rigid dependency: Users of your pallet must use the exact version of the coupled pallet.</li>
                        <li>Not modular: Hard to swap out dependencies.</li>
                    </ul>
                </li>
            </ul>

            <h4>8.2.4 Use Case</h4>
            <ul>
                <li>Required for frame_system (all pallets are tightly coupled to it).</li>
                <li>Use when you need deep integration with a specific pallet.</li>
            </ul>

            <h3>8.3 Loose Coupling</h3>
            <h4>8.3.1 How It Works</h4>
            <ul>
                <li><strong>Trait-Based Interface</strong>: Define an associated type in your pallet's Config that requires specific traits. Example:</li>
            </ul>

            <pre><code class="language-rust">#[pallet::config]
pub trait Config: frame_system::Config {
    type NativeBalance: Inspect<Self::AccountId> + Mutate<Self::AccountId>;
}</code></pre>

            <ul>
                <li>Here, <code>NativeBalance</code> must implement <code>fungible::Inspect</code> and <code>fungible::Mutate</code> traits.</li>
            </ul>

            <h4>8.3.2 Key Characteristics</h4>
            <ul>
                <li><strong>Trait-Bound Access</strong>: Use the other pallet's functionality through traits:</li>
            </ul>

            <pre><code class="language-rust">let balance = T::NativeBalance::total_balance(alice);
T::NativeBalance::mint_into(alice, amount)?;</code></pre>

            <ul>
                <li><strong>No Direct Dependency</strong>: The runtime can assign any pallet that implements the required traits.</li>
            </ul>

            <h4>8.3.3 Pros & Cons</h4>
            <ul>
                <li>✅ Pros:
                    <ul>
                        <li>Flexible: Users can swap out the underlying pallet (e.g., use pallet_assets instead of pallet_balances).</li>
                        <li>Decouples versioning: No strict dependency on a specific pallet version.</li>
                    </ul>
                </li>
                <li>❌ Cons:
                    <ul>
                        <li>Limited to the functionality defined by the traits.</li>
                    </ul>
                </li>
            </ul>

            <h4>8.3.4 Use Case</h4>
            <ul>
                <li>Use when you want your pallet to work with multiple implementations (e.g., different token standards).</li>
                <li>Common for fungible tokens, NFTs, or other generic functionalities.</li>
            </ul>

            <h3>8.4 Runtime Configuration Example</h3>
            <ul>
                <li><strong>Tight Coupling Setup</strong></li>
            </ul>

            <pre><code class="language-rust">// In your runtime (`runtime/src/lib.rs`):
impl pallet_kitties::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    // Tight coupling to `pallet_balances` is implicit via the `Config` trait.
}</code></pre>

            <ul>
                <li><strong>Loose Coupling Setup</strong></li>
            </ul>

            <pre><code class="language-rust">// In your runtime (`runtime/src/lib.rs`):
impl pallet_kitties::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type NativeBalance = pallet_balances::Pallet<Runtime>; // Assign `pallet_balances`
}</code></pre>

            <ul>
                <li>Here, pallet_balances implements Inspect and Mutate, so it satisfies the trait bounds.</li>
            </ul>

            <h2>9. Balance Type</h2>
            <ul>
                <li>The Balance type is ultimately configured inside <code>pallet_balances</code>, and we don't have direct access to that pallet because we used <strong>loose coupling</strong>.</li>
                <li>The way we can access the Balance type is through the <code>Inspect</code> trait of the <code>NativeBalance</code> associated type. Accessing it kind of funny, which is why we commonly introduce a <code>BalanceOf&lt;T&gt;</code> alias type like so:</li>
            </ul>

            <pre><code class="language-rust">// Allows easy access our Pallet's `Balance` type. Comes from `Fungible` interface.
pub type BalanceOf<T> =
    <<T as Config>::NativeBalance as Inspect<<T as frame_system::Config>::AccountId>>::Balance;</code></pre>

            <ul>
                <li><code>BalanceOf&lt;T&gt;</code> type is generic, which means we <strong>CANNOT</strong> write the following:</li>
            </ul>

            <pre><code class="language-rust">// This code doesn't work
fn add_one(input: BalanceOf<T>) -> BalanceOf<T> {
    input + 1u128
}</code></pre>

            <ul>
                <li><code>BalanceOf&lt;T&gt;</code> does have traits that we can use to interact with it. The key one being <code>AtLeast32BitUnsigned</code>. This means our <code>BalanceOf&lt;T&gt;</code> must be an <code>unsigned integer</code>, and must be at least <code>u32</code>. So it could be <code>u32</code>, <code>u64</code>, <code>u128</code>, or even bigger. This also means we would be able to write the following:</li>
            </ul>

            <pre><code class="language-rust">// This code does work
fn add_one(input: BalanceOf<T>) -> BalanceOf<T> {
    input + 1u32.into()
}</code></pre>

            <ul>
                <li>We can convert any <code>u32</code> into the <code>BalanceOf&lt;T&gt;</code> type because we know at a minimum <code>BalanceOf&lt;T&gt;</code> is <code>AtLeast32BitUnsigned</code>.</li>
                <li>BalanceOf&lt;T&gt; types will act just like two normal numbers of the same type. You can add them, divide them, etc. and even better, do safe math operations on all of them:</li>
            </ul>

            <pre><code class="language-rust">let total_balance: BalanceOf<T> = balance_1.checked_add(balance_2).ok_or(ArithmeticError::Overflow)?;</code></pre>

            <h2>10. Buy and Sell Kitties</h2>
            <p>To execute a purchase, we need to transfer two things:</p>
            <ul>
                <li>The token balance from the buyer to the seller.</li>
                <li>The kitty from the seller to the buyer.</li>
            </ul>

            <h3>10.1 Transfer the Native Balance</h3>
            <ul>
                <li>We already have a function to transfer kitties. To transfer the <code>NativeBalance</code>, you can use the <code>transfer API</code> which is included in the <code>fungible::Mutate</code> trait:</li>
            </ul>

            <pre><code class="language-rust">fn transfer(
    source: &AccountId,
    dest: &AccountId,
    amount: Self::Balance,
    preservation: Preservation
) -> Result<Self::Balance, DispatchError></code></pre>

            <ul>
                <li><strong>NOTE</strong>: To access this function, you will need import the trait to bring it in scope. To use functions defined within traits, you need to bring the trait into scope. This is a rust thing.</li>
                <li>The first 3 parameters here are easy enough to understand. We also have a 4th parameter which is <code>preservation: Preservation</code>. It is defined as follows:</li>
            </ul>

            <pre><code class="language-rust">/// The mode by which we describe whether an operation should keep an account alive.
pub enum Preservation {
    /// We don't care if the account gets killed by this operation.
    Expendable,
    /// The account may not be killed, but we don't care if the balance gets dusted.
    Protect,
    /// The account may not be killed and our provider reference must remain (in the context of
    /// tokens, this means that the account may not be dusted).
    Preserve,
}</code></pre>

            <h3>10.2 Propagate Up Errors</h3>
            <ul>
                <li>Both transfer functions need to succeed for the sale to complete successfully. If either one of them would fail, the whole purchase should fail.</li>
                <li>Thankfully, both of our transfer functions return a result, and to handle things correctly here, we just need to propagate up those errors. For that, we simply include <code>?</code> at the end of the function.</li>
                <li>If at any point our extrinsic or the logic inside the extrinsic returns an error, the whole extrinsic will fail and all changes to storage will be undone. This is exactly the same behavior you would expect from a smart contract, and keeps our state transition function functioning smoothly.</li>
            </ul>

            <h2>11. Associated Types v/s Trait Methods</h2>

            <h3>11.1 For trait methods (like transfer):</h3>
            <ul>
                <li>When a trait method is called, Rust can automatically figure out the trait bounds and associated types through type inference.</li>
                <li>That's why <code>T::NativeBalance::transfer(...)</code> works - Rust knows that <code>T::NativeBalance</code> implements <code>Mutate</code> from the <code>Config</code> trait bounds, and can infer the correct <code>AccountId</code> type.</li>
            </ul>

            <h3>11.2 For associated types (like Balance):</h3>
            <ul>
                <li>When accessing an associated type, Rust needs explicit information about which trait provides that associated type.</li>
                <li><code>Balance</code> is an associated type that comes from the <code>Inspect</code> trait, not directly from <code>NativeBalance</code>.</li>
                <li>Just writing <code>T::NativeBalance::Balance</code> doesn't tell Rust which trait's <code>Balance</code> we want to use.</li>
                <li>That's why we need the fully qualified syntax for the type alias.</li>
            </ul>
        </div>
    </div>
</body>
</html>
