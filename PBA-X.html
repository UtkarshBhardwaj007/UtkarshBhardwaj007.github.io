<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PBA-X - Utkarsh Bhardwaj</title>
    <link rel="stylesheet" href="assets/css/styles.css">
</head>
<body>
    <div class="container">
        <div class="content">
            <a href="index.html" class="back-link">
                <span class="icon">←</span> Back to Home
            </a>

            <h1>PBA-X</h1>

            <h2>1. Cryptography</h2>
            <h3>1.1 Kerckhoff's Principle:</h3>
            <p>A cryptographic system should be secure even if everything about the system, except the key, is public knowledge.</p>

            <h3>1.2 Hashing attacks</h3>
            <ul>
                <li><strong>Preimage Attack</strong>: Given a hash value h, find any message m such that <code>hash(m) = h</code>. Trying to find an input that produces a specific target hash</li>
                <li><strong>Weak Collision Attack (Second Preimage Attack)</strong>: Given a message <code>m1</code>, find another message <code>m2</code> such that <code>hash(m1) = hash(m2)</code>.</li>
                <li><strong>Strong Collision Attack</strong>: Find any two different messages <code>m1</code> and <code>m2</code> such that hash(m1) = hash(m2). Can use any two inputs, not tied to a specific input or hash.</li>
            </ul>

            <h3>1.3 Encryption</h3>
            <ul>
                <li>Symmetric key encryption is less computationally expensive, so faster, than asymmetric key encryption.</li>
                <li>So we try to share the symmetric keys securely and then use them for communication. 2 ways to share keys:
                    <ul>
                        <li><strong>Diffie Hellman key exchange</strong>: Both parties involved create unique secret keys. Then they share a common <code>base</code> and <code>modulus</code> and use modular arithmetic to calculate a shared secret key.</li>
                        <li><strong>Asymmetric Key Encryption (RSA)</strong>: Here both parties create separate public and private keys. The public key is shared with the other party and the private key is kept secret. Both parties use this secure channel to share a symmetric key.</li>
                    </ul>
                </li>
            </ul>

            <h3>1.4 Wallet and Accounts</h3>
            <ul>
                <li>A crypto wallet doesn't store any crypto assets. It stores the private keys which prove ownership of the crypto assets.</li>
                <li>The public key is the wallet address.</li>
                <li>Pneumonic phrases are a way to generate a private key from a random string of words.</li>
                <li>We can't remember a <code>2048</code> bit private key, so we use a pass phrase to generate it. The magic here is that we change the base of the private key from <code>2</code> to <code>58</code> (in case of polkadot) so that the private keys becomes shorter and is easy to remember.</li>
                <li>The specific address format used in polkadot is <code>SS58</code> format. <code>SS58</code> is a base58 encoding of the public key and it adds <code>2</code> bytes at the beginning to "indicate the network". It also adds <code>2</code> bytes at the end for <code>Checksum</code>.</li>
                <li><strong>Hard Derived Account</strong>: Has it's own private key and public key. Created with <code>\</code> (2 slashes).</li>
                <li><strong>Soft Derived Account</strong>: Has it's own public key and shares the private key with the parent account. Created with <code>/</code> (1 slash).</li>
            </ul>

            <h3>1.5 Digital Signatures</h3>
            <ul>
                <li>A digital signature is a mathematical scheme for verifying the authenticity of a digital message or document.</li>
                <li>Guaranteed properties of a Digital Signature scheme in the context of transactions:
                    <ul>
                        <li><strong>Authenticity</strong>: a valid signature implies that the signer deliberately signed the transaction.</li>
                        <li><strong>Unforgeability</strong>: it is computationally infeasible to forge a signature without knowledge of the private key.</li>
                        <li><strong>Non-repudiation</strong>: the signer cannot later deny having signed the message</li>
                        <li><strong>Integrity</strong>: ensure the transaction data has not been modified</li>
                    </ul>
                </li>
                <li>It consists of 3 algorithms:
                    <ul>
                        <li><strong>Key Generation</strong>: Generate a public and private key pair.</li>
                        <li><strong>Signing Algorithm</strong>: Uses the private key and the message to create a signature.</li>
                        <li><strong>Verification Algorithm</strong>: Uses the public key and the original message and the signature to verify if the signature is valid. The signature will only verify correctly if the message hasn't been tampered with and the public key corresponds to the private key that was used to create the signature.</li>
                    </ul>
                </li>
                <li><strong>In Practice</strong> digital signatures don't sign the entire message. Instead a hash function is used to hash the message and create a <code>Digest</code> or <code>Fingerprint</code> of fixed length. The reason for this is that Cryptographic hashing functions usually work on fixed size inputs.</li>
                <li>One challenge that Digital signatures address is <code>Replay Attacks</code>. A replay attack is when an attacker captures a message and then later re-sends it to the recipient. The recipient can't tell if the message is new or old. To prevent this, Digital signatures often use additional information like <code>nonces</code> and <code>timestamps</code>/<code>lifetimes</code>.</li>
                <li><strong>Multisig accounts</strong> are accounts that require multiple signatures to authorize a transaction. This is useful for things like other decentralized organizations.</li>
            </ul>

            <h3>1.6 Hash Based Data Structures</h3>

            <h4>1.6.1 Hash Chains</h4>
            <ul>
                <li>A hash chain is a fundamental data structure used in blockchains to ensure the integrity and immutability of data. It is a sequence of blocks (objects), each containing data and a cryptographic hash of the previous block, forming a chain (could be anything like vector or list). This structure ensures that any alteration in a block would require changes to all subsequent blocks, making it tamper-evident.</li>
                <li>Most blockchain implementations (including major ones like Bitcoin) store blocks in a database or vector and use the hash values for validation, not traversal.</li>
            </ul>

            <h4>1.6.2 Merkle Tries</h4>
            <ul>
                <li>Merkle tree also known as hash tree is a data structure used for data verification and synchronization.</li>
                <li>It is a tree data structure where each non-leaf node is a hash of it's child nodes. All the leaf nodes are at the same depth and are as far left as possible.</li>
                <li>Each transaction gets hashed, Hashes are paired and hashed again, Process repeats until single root hash, Root hash goes in block header of the blockchain block.</li>
                <li>It is called a <code>merkle "trie"</code> because the trie data structure is used to reduce the amount of redundant data stored in the tree.</li>
                <li>Whereas reading and writing to a database could be considered <code>O(1)</code>, a merklized database has read and write complexity of <code>O(log N)</code>, where <code>N</code> is the total number of items stored in the database.</li>
                <li>The primary advantage of using a merkle trie is that proving specific data exists inside the database is much more efficient! Whereas you would normally need to share the <code>whole database</code> to prove that some data exists, with a merklized database, you only need to share <code>O(log N)</code> amount of data. This is very important to support <code>light clients</code>.</li>
            </ul>

            <p><img src="images/merkle-tree.png" alt="Diagram Description"></p>

            <h4>1.6.3 Merkle Mountain Range</h4>
            <ul>
                <li>A Merkle Mountain Range (MMR) is a variation of Merkle Trees that allows efficient appending of new elements. Think of it as a collection of perfect binary trees of different heights, forming a "mountain range" profile.</li>
                <li>Efficient appending O(log n), Easy to prove membership, Good for growing datasets, Used in blockchain UTXO sets.</li>
            </ul>

            <p><img src="images/UTXO-mmr-mgmt.png" alt="Diagram Description"></p>

            <ul>
                <li>MMR provides a way for blockchain UTXO management. When new transaction creates UTXOs:
                    <ul>
                        <li>Hash the new UTXOs</li>
                        <li>Add to MMR structure</li>
                        <li>Update peaks if needed</li>
                    </ul>
                </li>
                <li>When spending UTXOs:
                    <ul>
                        <li>Prove UTXO exists using MMR path</li>
                        <li>Remove spent UTXO</li>
                        <li>Add new UTXOs from transaction</li>
                    </ul>
                </li>
            </ul>

            <h4>1.6.4 Radix/Patricia Tries</h4>
            <ul>
                <li>A Patricia Trie (Practical Algorithm To Retrieve Information Coded In Alphanumeric) is a modified trie that compresses nodes with only one child, making it more space-efficient. In blockchains, it's used to store state data efficiently.</li>
            </ul>

            <p><img src="images/patricia-trie.png" alt="Diagram Description"></p>

            <h3>1.7 Advanced Cryptography Topics</h3>

            <h4>1.7.1 Shamir Secret Sharing</h4>
            <ul>
                <li>Shamir Secret Sharing is a cryptographic method to split a secret into n shares, where any k shares (threshold) can reconstruct the secret, but k-1 or fewer shares reveal nothing about the secret.</li>
            </ul>

            <h4>1.7.2 Verifiable Random Functions (VRFs)</h4>
            <p>A VRF is a cryptographic function that:</p>
            <ul>
                <li>Takes an input and private key to generate a random number</li>
                <li>Provides a proof that the number was generated correctly</li>
                <li>Anyone can verify the proof using the public key</li>
                <li>Same input + private key always gives same output</li>
                <li>Output appears random to anyone without the private key</li>
            </ul>

            <h4>1.7.3 Zero-Knowledge Proofs (ZKPs)</h4>
            <ul>
                <li>A zero knowledge proof is a method where one party (prover) can prove to another party (verifier) that a statement is true without revealing any information beyond the validity of the statement.</li>
            </ul>

            <h2>2. Fundamentals of blockchains</h2>

            <h3>2.1 Blockchain Concepts Pre-Quiz:</h3>
            <ul>
                <li>Bitcoin uses <code>UTXO</code> model instead of the <code>Accounts</code> model to process transactions.</li>
                <li>Typically, The hash of the NFT images and videos is stored on the blockchain network. The original content is stored typically on a decentralized storage platform which may or may not use blockchain technology stack. Storing them directly on the blocks or in the blockchain state can be expensive and is an inefficient implementation of the NFT use case.</li>
                <li>Just because the transaction shows up on Bitcoin block explorers does not mean the transaction is final. The finality of the Bitcoin blockchain is probabilistic. That is why central exchanges wait a couple of hours before letting you transact with the Bitcoin you deposited on their platform.</li>
                <li>The security guarantees offered by Ethereum Roll-ups (Layer 2 chains) are <strong>NOT</strong> the same as the security guarantees of the Ethereum network (Layer 1 chain).</li>
                <li>Blockchain network's security and resilience to attacks rely on factors like decentralization, consensus mechanisms, and protocol design.</li>
            </ul>

            <h3>2.2 Blockchain Networks:</h3>

            <h4>2.2.1 Types of Decentralization</h4>
            <ul>
                <li><strong>Architectural Decentralization</strong>: To address single point of failures in the network (Distributed systems)</li>
                <li><strong>Political Decentralization</strong>: Who gets to decide how the blockchain should operate? What is the governance model?</li>
                <li><strong>Logical Decentralization</strong>: Blockchains may be politically decentralized (no one controls them) and architecturally decentralized (no infrastructural central point of failure) but they are logically centralized. There is one commonly agreed state and the system behaves like a single computer. Most blockchains are logically centralized.</li>
            </ul>

            <h3>2.3 Blockchain Architecture</h3>
            <ul>
                <li>Blockchain architecture consists of multiple layers, each with specific functions:
                    <ul>
                        <li><strong>Application Layer</strong>: Top-most layer where users interact with blockchain. Includes dApps, smart contracts, wallets, and user interfaces. Provides services and functionality to end users</li>
                        <li><strong>Consensus Layer</strong>: Ensures all nodes agree on the state of the blockchain. Implements consensus mechanisms (PoW, PoS, etc.). Validates and orders transactions</li>
                        <li><strong>Network Layer</strong>: Handles peer-to-peer communication between nodes. Manages transaction and block propagation. Maintains network connectivity and node discovery</li>
                        <li><strong>Data Layer</strong>: Defines structure of blockchain data (blocks, transactions). Implements cryptographic primitives and data structures. Handles data storage and retrieval</li>
                        <li><strong>Infrastructure Layer</strong>: Base layer providing hardware and software requirements. Includes nodes, physical networks, and computing resources. Supports basic blockchain operations</li>
                    </ul>
                </li>
            </ul>

            <p><img src="images/blockchain-architecture-layers.png" alt="Diagram Description"></p>

            <ul>
                <li>Different <strong>types of blockchain architectures</strong>:</li>
            </ul>

            <p><img src="images/kinds-of-blockchain-architectures.png" alt="Diagram Description"></p>

            <ul>
                <li>Layers in Blockchain Ecosystem Architecture:
                    <ul>
                        <li><strong>Layer 0</strong>: Network infrastructure protocols that allow blockchains to be built and communicate
                            <ul>
                                <li>Not a blockchain itself</li>
                                <li>A foundation layer/protocol</li>
                                <li>Example: Polkadot isn't a blockchain, it's a protocol that allows creation and connection of blockchains (parachains)</li>
                            </ul>
                        </li>
                        <li><strong>Layer 1</strong>: Actual base blockchains
                            <ul>
                                <li>These ARE blockchains</li>
                                <li>Independent networks with their own consensus</li>
                                <li>Example: Ethereum is a L1 blockchain</li>
                            </ul>
                        </li>
                        <li><strong>Layer 2</strong>: Scaling solutions built ON TOP of L1 blockchains
                            <ul>
                                <li>Not independent blockchains</li>
                                <li>Solutions that extend L1 capabilities</li>
                                <li>Example: Optimism isn't its own blockchain, it's a scaling solution for Ethereum</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>

            <h3>2.4 Blockchain Trilemma</h3>
            <ul>
                <li>The Blockchain Trilemma refers to the fundamental challenge in blockchain design where it's seemingly impossible to achieve all three key properties simultaneously:
                    <ul>
                        <li>Decentralization</li>
                        <li>Security</li>
                        <li>Scalability</li>
                    </ul>
                </li>
            </ul>

            <h3>2.5 Blockchain Consensus</h3>

            <h4>2.5.1 Layers of Consensus</h4>
            <p>These are used in consensus mechanisms to filter out chains until we find the canonical chain.</p>
            <ul>
                <li><strong>State Machine Validity</strong>: This checks if the history of transaction (<code>State Transitions</code>) are valid.</li>
                <li><strong>Political Validity</strong>: We might reject blocks that don't meet certain <code>political</code> or <code>arbitrary</code> rules. For example, in Bitcoin, blocks bigger than 1MB are rejected.</li>
                <li><strong>Right to Author</strong>: This checks if the block was authored by the right person who was elected to author the block.</li>
                <li><strong>Fork Choice</strong>: Each node has its own view of the blockchain and decides, based on that, if the current block is valid or not. A block in an invalid fork would be rejected.</li>
            </ul>

            <h4>2.5.2 Consensus Mechanisms</h4>
            <ul>
                <li><strong>Proof of Work (PoW)</strong>: 
                    <ul>
                        <li>It is a <code>permissionless</code> consensus mechanism that requires miners to solve complex mathematical problems to validate transactions and add new blocks to the blockchain. It ties the blockchain's value to a real world scarce resource (energy).</li>
                        <li>Downsides: It is energy-intensive and the blocks are produced at varying times.</li>
                    </ul>
                </li>
                <li><strong>Proof of Stake (PoS)</strong>:
                    <ul>
                        <li>A consensus mechanism where validators stake (lock up) cryptocurrency to get the right to validate blocks. The more you stake, the higher chance of being selected to validate.</li>
                    </ul>
                </li>
                <li><strong>NOTE</strong>: <code>PoW</code> and <code>PoS</code> are mechanisms for <code>block authoring</code>. Consensus on <code>block finality</code> is achieved through finality gadgets like <code>GRANDPA</code> for deterministic block finality.</li>
            </ul>

            <h4>2.5.3 Block Finality Mechanisms</h4>

            <ul>
                <li><strong>Block Finality</strong>: The guarantee that a block cannot be reverted/changed once added to the chain.</li>
                <li><strong>Finality Gadgets</strong>: These are mechanisms that allow a blockchain to reach <code>Deterministic Finality</code>. In Polkadot, the primary finality gadget is <code>GRANDPA</code>(GHOST-based Recursive Ancestor Deriving Prefix Agreement).</li>
            </ul>

            <h5>2.5.3.1 Probabilistic Finality</h5>
            <ul>
                <li>Finality becomes stronger over time. More blocks = more certainty. Used in BTC.</li>
                <li>There is always a risk of reverting a block if a longer chain is found.</li>
            </ul>

            <h5>2.5.3.2 Deterministic Finality</h5>
            <ul>
                <li>Finality is guaranteed. Once confirmed, block cannot be reverted. Used in PoS systems like Polkadot. Example: After 2/3 validators sign, block is final.</li>
                <li>There is no risk of reverting a block.</li>
            </ul>

            <h5>2.5.3.3 GRANDPA</h5>
            <ul>
                <li><code>GRANDPA</code> is responsible for finalising blocks in polkadot.</li>
                <li>Polkadot uses a two-phase voting system (<code>Hybrid Consensus Model</code>) to reach finality. It separates the block production from block finality.</li>
            </ul>

            <h4>2.5.4 Forks in Blockchain</h4>
            <ul>
                <li><strong>Soft Fork</strong>: A change to the protocol that is backward compatible. Tightens/adds rules. Old nodes can still validate blocks.</li>
                <li><strong>Hard Fork</strong>: A change to the protocol that is not backward compatible. Changes fundamental rules. Old nodes will reject new blocks.</li>
            </ul>

            <h3>2.6 Blockchain Node v/s Runtime</h3>

            <p><img src="images/Node-vs-runtime.png" alt="Diagram Description"></p>

            <h2>3. Polkadot</h2>
            <h3>3.1 Blockchain</h3>
            <p>A blockchain is, in its essence, a distributed and decentralized key-value database. The principle of a blockchain is to make it possible for any participant to perform modifications to this database, and for all participants to eventually agree on the current state of said database.</p>

            <p>In Polkadot and Substrate-compatible chains, the state of this database is referred to as "the storage". The storage can be seen more or less as a very large HashMap.</p>

            <p>A blockchain therefore consists in three main things:</p>
            <ol>
                <li>The initial state of the storage at the moment when the blockchain starts</li>
                <li>A list of blocks, where each block represents a group of modifications performed to the storage</li>
                <li>A peer-to-peer network of clients connected to each other and exchanging information such as newly-produced blocks</li>
            </ol>

            <p>Blocks are built on top of each other, forming a sequential list of modifications to the storage on top of its initial state.</p>

            <h3>3.2 Polkadot Architecture</h3>

            <p>Polkadot is a heterogeneous multichain with shared security and interoperability.</p>

            <p><img src="images/polkadot-architecture.png" alt="Diagram Description"></p>

            <h4>3.2.1 Relay Chain - A Layer 0 Blockchain</h4>
            <p>The Relay Chain is the central chain of Polkadot. The Relay Chain has deliberately minimal functionality - for instance, smart contracts are not supported. The main responsibility is to coordinate the system as a whole, including parachains. Other specific work is delegated to the parachains, which have different implementations and features.</p>

            <h4>3.2.2 Parachains and Parathreads</h4>
            <p>Polkadot can support a number of execution slots. These slots are like cores on a computer's processor (a modern laptop's processor may have eight cores, for example). Each one of these cores can run one process at a time.</p>

            <p>Polkadot allows these slots using two subscription models:</p>
            <ul>
                <li><strong>Parachains</strong>: Have a dedicated slot (core) for their chain and are like a process that runs constantly</li>
                <li><strong>Parathreads</strong>: Share slots amongst a group, and are thus more like processes that need to be woken up and run less frequently</li>
            </ul>

            <h4>3.2.3 Validator</h4>
            <p>Validators are the Relay chain nodes that, if elected to the validator set, produce blocks on the Relay Chain. They are incentivized to act in the best interests of the network through rewards.</p>

            <h4>3.2.4 Collator</h4>
            <p>Collators are full nodes on both a parachain and the Relay Chain. They:</p>
            <ul>
                <li>Collect parachain transactions</li>
                <li>Produce state transition proofs for the validators on the Relay Chain</li>
                <li>Can send and receive messages from other parachains</li>
                <li>Maintain a full node of the parachain</li>
                <li>Retain all necessary information of the parachain</li>
                <li>Produce new block candidates to pass to the Relay Chain validators for verification and inclusion in the shared state of Polkadot</li>
            </ul>

            <h4>3.2.5 Bridges</h4>
            <p>A blockchain bridge is a connection that allows for arbitrary data to transfer from one network to another. These chains are interoperable through the bridge but can exist as standalone chains with different protocols, rules, and governance models.</p>

            <p>In Polkadot, bridges:</p>
            <ul>
                <li>Connect to the Relay Chain</li>
                <li>Are secured through the Polkadot consensus mechanism</li>
                <li>Are maintained by collators</li>
            </ul>

            <h2>4. Polkadot SDK</h2>
            <h3>4.1 Polkadot SDK Overview</h3>
            <ul>
                <li><strong>Polkadot SDK</strong>: A collection of tools and libraries that help developers build applications on the Polkadot network.</li>
                <li><strong>Polkadot SDK Components</strong>: The SDK has 3 main components:
                    <ul>
                        <li><strong><code>Substrate</code></strong>: A framework for building blockchains. This is the foundational framework of Polkadot SDK. It includes core components like networking, transaction pools and APIs.</li>
                        <li><strong><code>FRAME</code></strong>: A collection of modules that provide common functionality for building blockchain applications. This is built on top of Substrate and defines the Application logic of the blockchain.</li>
                        <li><strong><code>Cumulus</code></strong>: This is a lighter layer in the SDK which enables <code>substrate</code> based chains to be compatible with Polkadot.</li>
                    </ul>
                </li>
                <li><strong><code>ZombieNet</code></strong>: It helps simulate a relay chain and parachain node setup on a local machine for testing the features and functionalities of a parachain (end-to-end testing for parachains on a local machine).</li>
                <li><strong><code>Chopsticks</code></strong>: Chopsticks is a tool that can be used to test blockchain runtime. It simulates just the relay chain and parachain runtimes without running the nodes and can be used for testing runtime features. Chopsticks is a versatile, light weight testing tool for cross-chain functionality in the Polkadot ecosystem. Chopsticks tooling can be used to test cross-chain functionalities between Polkadot and parachains, as well as the functionalities between different parachains.</li>
            </ul>

            <h3>4.2 Substrate (PolkadotSDK's blockchain building framework)</h3>
            <ul>
                <li><strong>Substrate</strong>: A framework for building blockchains. It provides a set of tools and libraries for building blockchains, including networking, transaction pools, APIs, and other core components. It is mostly un-opinionated and allows developers to build their own blockchain applications. It has the following features:
                    <ul>
                        <li><strong>Modularity</strong>: Substrate is modular, allowing developers to choose which components they want to use and build their blockchain on top of it.</li>
                        <li><strong>Flexibility</strong>/<strong>Extensibility</strong>: Substrate is extensible and customizable, allowing developers to add their own functionality to the blockchain.</li>
                        <li><strong>Upgradability</strong>: Substrate is designed to be upgradable, allowing developers to upgrade their blockchain without downtime. The forkless and seamless upgrades are a distinctive feature of the Polkadot SDK.</li>
                    </ul>
                </li>
            </ul>

            <h4>4.2.1 Substrate Wasm Meta Protocol</h4>

            <ul>
                <li><strong>Meta Protocol</strong>: A meta protocol is a protocol that defines rules for creating and modifying other protocols. In the context of <code>Polkadot</code> and <code>Substrate</code>, the <code>Substrate Wasm Meta Protocol</code> refers to a mechanism for <code>defining</code>, <code>updating</code>, and <code>executing</code> the logic that governs the blockchain runtime.</li>
                <li><strong>Wasm</strong>: WebAssembly (Wasm) is a lightweight, platform-agnostic binary instruction format designed for high-performance applications. It allows code written in languages like Rust, C++, or Go to run in web browsers and other environments, including blockchains. It is a portable, efficient runtime execution environment.</li>
                <li><strong>Substrate Wasm Meta Protocol</strong>: The Substrate Wasm Meta Protocol describes the dynamic, modular architecture in Substrate and Polkadot, where:
                    <ul>
                        <li>Blockchain Runtime:
                            <ol>
                                <li>Encapsulated in a Wasm binary.</li>
                                <li>Contains all the business logic, including consensus mechanisms, transaction validation rules, and governance processes.</li>
                            </ol>
                        </li>
                        <li>Runtime Upgrades:
                            <ol>
                                <li>Instead of requiring hard forks, the runtime logic can be upgraded on-chain by submitting a new Wasm binary.</li>
                                <li>The meta protocol defines the process for proposing, validating, and deploying these upgrades.</li>
                            </ol>
                        </li>
                        <li>Chain Flexibility:
                            <ol>
                                <li>Because the runtime is abstracted, a single chain can evolve its behavior over time. This enables rapid development and adaptation to new use cases or requirements.</li>
                            </ol>
                        </li>
                    </ul>
                </li>
            </ul>

            <p><img src="images/substrate-based-node.svg" alt="Diagram Description"></p>

            <p><img src="images/substrate|node|runtime.png" alt="Diagram Description"></p>

            <p><img src="images/comm-path-in-node.png" alt="Diagram Description"></p>

            <h3>4.3 Polkadot SDK Storage Overview</h3>
            <ul>
                <li>Blocks: Stored sequentially, containing transactions and state root hashes.</li>
                <li>Current State: Stored in a Merkle Trie, with the state root hash providing a compact representation.</li>
                <li>Database: In Polkadot, RocksDB (or optionally ParityDB) is used - these are NoSQL, key-value databases. The same database stores both blocks and state, but in different ways:

                    <ul>
                        <li>Block Storage:</li>
                    </ul>
                    <pre><code>  Key                     Value
  -----------------------------------------
  block:0                 &lt;block_0_data&gt;
  block:1                 &lt;block_1_data&gt;
  block:2                 &lt;block_2_data&gt;
  block_hash:0xabc...     &lt;block_data&gt;      # Hash-based lookup</code></pre>

                    <ul>
                        <li>State Storage:</li>
                    </ul>
                    <pre><code>  Key                              Value
  -----------------------------------------
  state:account:alice              &lt;account_data&gt;
  state:balance:alice             100
  state:custom_pallet:counter     42</code></pre>

                    <ul>
                        <li><strong>How it works</strong>:
                            <br>The database itself doesn't know about sequences or trees. The node software:
                            <ul>
                                <li>Uses prefix-based keys for different data types</li>
                                <li>Implements Merkle trie logic in code and Manages state trie structure</li>
                                <li>Maintains relationships between data</li>
                                <li>Handles sequential block access</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>

            <h3>4.4 Extrinsics in Polkadot SDK</h3>
            <p>In Polkadot SDK based blockchains, the transactions (extrinsics) can be:</p>
            <ul>
                <li><strong>Signed</strong>: These are transactions that have been signed by the sender and are ready to be included in a block.</li>
                <li><strong>Unsigned</strong>: These are transactions that have been submitted without a signature, often requiring custom validation logic.</li>
                <li><strong>Inherent</strong>: typically inserted directly into blocks (like current timestamp) by block authoring nodes, without gossiping between peers</li>
            </ul>

            <h3>4.5 Off Chain Workers (OWCs) and Oracles in Polkadot SDK</h3>
            <ul>
                <li><strong>Off-chain Workers (OWCs)</strong>: These are background tasks that run outside of the blockchain's consensus process. They can be used for various purposes, such as fetching data from external sources, executing complex computations, or performing other tasks that don't require consensus. OCWs run OUTSIDE the blockchain's deterministic environment.</li>
                <li><strong>Oracles</strong>: Oracles are EXTERNAL services that submit data TO the blockchain in the form of transactions.</li>
            </ul>

            <ul>
                <li>Practical Application:</li>
            </ul>
            <pre><code>  Use Case    → Implementation Choice

  Low-value data     → OCW direct fetch
  High-value data    → Oracle service
  Complex compute    → OCW processing
  Critical data      → Multiple oracles</code></pre>

            <ul>
                <li>Integration Paths:</li>
            </ul>
            <pre><code>  Parachain A                    Parachain B
      ├── OCW fetches data          ├── Uses oracle data
      ├── Validates locally         ├── Pays for access
      └── Submits to chain          └── Trusts oracle source</code></pre>

            <h2>5. FRAME</h2>
            <ul>
                <li><strong>FRAME</strong> is a rust-based framework for building Substrate-based blockchains/substrate runtimes by providing re-usable building blocks.</li>
            </ul>

            <h3>5.1 Pallets</h3>
            <ul>
                <li>FRAME takes the opinion that the blockchain runtime should be composed of individual modules called <code>pallets</code>.</li>
            </ul>
            <p><img src="images/frame-overview.png" alt="Diagram Description"></p>
            <ul>
                <li>Essential components of a <code>pallet</code>:
                    <ul>
                        <li><strong>Calls/Dispatchable Extrinsics</strong>: These are functions that can be called on the pallet. They can be used to interact with the blockchain, such as transferring balance. A transaction will specify the call to dispatch.</li>
                        <li><strong>Storage Items</strong>: These are the data that the pallet manages. They can be stored in the blockchain's state.</li>
                        <li><strong>Events</strong>: These are the events that the pallet emits. They can be used to notify users of important events, such as a balance change.</li>
                        <li><strong>Errors</strong>: These are the errors that the pallet can return. They can be used to indicate that a call failed.</li>
                        <li><strong>Hooks</strong>: Hooks allow you to define logic that runs at specific points in the lifecycle of a block such as the beginning or end of a block.</li>
                    </ul>
                </li>
            </ul>

            <h2>6. XCM</h2>
            <ul>
                <li><strong>XCM</strong> (Cross-Chain Messaging) is a <strong>language</strong> for communicating <strong>intentions</strong> between <strong>Consensus Systems</strong>. It allows different blockchains to communicate with each other. It is a way for different blockchains to interact with each other, such as transferring assets, executing smart contracts, or performing other tasks that don't require consensus.</li>
                <li>XCM adheres to four guiding principles that ensure robust and reliable communication across consensus systems:
                    <ul>
                        <li><strong>Asynchronous</strong> - XCM messages operate independently of sender acknowledgment, avoiding delays due to blocked processes</li>
                        <li><strong>Absolute</strong> - XCM messages are guaranteed to be delivered and interpreted accurately, in order, and timely. Once a message is sent, one can be sure it will be processed as intended</li>
                        <li><strong>Asymmetric</strong> - XCM messages follow the 'fire and forget' paradigm meaning no automatic feedback is provided to the sender. Any results must be communicated separately to the sender with an additional message back to the origin</li>
                        <li><strong>Agnostic</strong> - XCM operates independently of the specific consensus mechanisms, making it compatible across diverse systems.</li>
                    </ul>
                </li>
            </ul>

            <h2>7. Parachains</h2>
            <ul>
                <li>Parachains are Polkadot's unique version of shards or roll-ups functioning as parallel block chains that independently run and process transactions.</li>
                <li>Parachain network maintains its own blockchain and state. Polkadot validators process the parachain blocks and hold them for a short time (24 hours) for data availability for approvals and disputes processing. The Polkadot relay chain only stores a shortened digest of the parachain block. Storing the whole blocks indefinitely would bloat the Polkadot blockchain and beats the purpose of sharding.</li>
            </ul>

            <h3>7.1 Collators</h3>
            <ul>
                <li><strong>Parachain-Specific Nodes</strong>: Collators are nodes specific to a parachain, not randomly selected from the Polkadot Relay Chain. They maintain the full state of their parachain, collect transactions, and produce blocks for validation.</li>
                <li><strong>Block Authors</strong>: They act as block producers (similar to "miners" or "validators" in other chains) for their parachain, creating candidate blocks to be validated by Polkadot's Relay Chain validators.</li>
                <li>If you create a parachain, you must run your own collator nodes. Polkadot does not provide collators; they are the responsibility of the parachain team. Collators ensure the parachain remains operational by producing blocks and interacting with the Relay Chain.</li>
            </ul>

            <h3>7.2 Backing Group / Polkadot Core / Execution Core</h3>
            <ul>
                <li>A <strong>subset</strong> of Polkadot's Relay Chain validators (randomly assigned to parachains) verifies parachain blocks. They check validity and availability before inclusion in the Relay Chain.</li>
                <li><strong>Consensus Finalization</strong>: While collators produce blocks, finality is achieved only after Relay Chain validators approve them. This ensures shared security across Polkadot.</li>
            </ul>

            <p><img src="images/storage-relay-vs-parachain.svg" alt="Diagram Description"></p>

            <h3>7.3 Parachain Block Validation and Inclusion</h3>

            <pre><code>                            Polkadot Data Availability Process
                                     +-----------------------+
                                     |     Parachain Block    |
                                     | (Collation by Collator)|
                                     +-----------+-----------+
                                                 |
                                                 v
                                     +-----------------------+
                                     |   Backing Group       |
                                     | (Validate Correctness)|
                                     +-----------+-----------+
                                                 |
                                                 v
                                     +-----------------------+
                                     | Reed-Solomon Erasure  |
                                     | Coding & Distribution |
                                     +-----------+-----------+
                                                 |
                                                 v
               +---------------------+--------------------------+---------------------+
               |                     |                          |                     |
               v                     v                          v                     v
      +----------------+   +----------------+         +----------------+   +----------------+
      | Validator 1    |   | Validator 2    |   ...   | Validator N    |   | Validator N+1  |
      | (Chunk Storage)|   | (Chunk Storage)|         | (Chunk Storage)|   | (Chunk Storage)|
      +----------------+   +----------------+         +----------------+   +----------------+
                                                 |
                                                 v
                                     +-----------------------+
                                     | Relay Chain Block     |
                                     | - Parachain Header    |
                                     | - Erasure-Coded Root  |
                                     | - Validity Proofs     |
                                     +-----------------------+</code></pre>

            <h4>7.3.1 Overview</h4>
            <p>After a collator creates a parachain block (collation), it undergoes two critical stages before being included in the Relay Chain block:</p>
            <ol>
                <li><strong>Backing Process</strong>: The collation is validated by a subset of Relay Chain validators (the backing group) to ensure correctness.</li>
                <li><strong>Data Availability Stage</strong>: Ensures the collation's data is stored redundantly across the network so it can be reconstructed later if needed.</li>
                <li><strong>Approval Checking and Disputes</strong>: A <strong>random subset of validators</strong> (not in the backing group) is selected to re-check the block. Validators submit approval votes to the Relay Chain. If there is even one validator which rejected the collation, it creates a <code>Dispute</code> and all validators in the relay chain then verify the collation and the stake of the malicious actor gets slashed.</li>
                <li><strong>Finalization</strong>: In the end, the block is finalized via <code>GRANDPA</code> (Polkadot's finality gadget). <code>GRANDPA</code> would never finalize a disputed block.</li>
            </ol>

            <h4>7.3.2 Collation vs PoV (Proof of Validity) Block</h4>
            <p>Key Differences</p>
            <p>Aspect	Collation	Proof of Validity (PoV)</p>
            <p>Content	Transactions, state changes, block data.	Cryptographic proof of the collation's validity.</p>
            <p>Created By	Collators (parachain-specific nodes).	Collators (using the parachain's logic).</p>
            <p>Role in Validation	Raw data to be validated.	Enables efficient validation by Relay Chain.</p>
            <p>Storage	Stored on parachain nodes.	Submitted to Relay Chain alongside collations.</p>
            <p>Dependency	Standalone block data.	Dependent on the collation it proves.</p>

            <h4>7.3.3 Key Steps</h4>
            <ul>
                <li><strong><code>Reed-Solomon Erasure Coding</code></strong>: The parachain block data is split into N chunks and encoded into 2N chunks using Reed-Solomon codes. Even if up to N chunks are lost, the original data can still be recovered.
                    <ul>
                        <li><strong>Why?</strong>: To prevent data withholding attacks (e.g., a malicious validator hiding data to break consensus).</li>
                        <li><strong>Distribution</strong>: Chunks are distributed to all Relay Chain validators, not just the backing group.</li>
                    </ul>
                </li>

                <li><strong><code>Data Availability Confirmation</code></strong>: Validators attest that they've received their assigned chunks. Once a threshold of validators (e.g., 2/3) confirms availability, the collation is marked as "available."</li>

                <li><strong>Inclusion in the Relay Chain</strong>: The Relay Chain does not store the full parachain block. Instead, it stores:
                    <ul>
                        <li><code>Parachain Block Header</code>: A condensed summary of the parachain block.</li>
                        <li><code>Erasure-Coded Root</code>: A cryptographic commitment (e.g., Merkle root) to the erasure-coded chunks. Proof that the parachain block data is available and recoverable.</li>
                        <li><code>Validity Attestations</code>: Signatures from the backing group confirming the block's validity.</li>
                    </ul>
                </li>
            </ul>

            <p><img src="images/data-availability-from-parachains.svg" alt="Diagram Description"></p>
        </div>
    </div>
</body>
</html>
                                <li>A